/************************************************************************
 *                                                                      *
 * Copyright 2020 AvatarIn Inc. Tokyo, Japan. All Rights Reserved       *
 *                                                                      *
 *       _____               __               .___                      *
 *      /  _  \___  ______ _/  |______ _______|   | ____                *
 *     /  /_\  \  \/ |__  \\   __\__  \\_  __ \   |/    \               *
 *    /    |    \   / / __ \|  |  / __ \|  | \/   |   |  \              *
 *    \____|__  /\_/ (____  /__| (____  /__|  |___|___|  /              *
 *            \/          \/          \/               \/               *
 *                                                                      *
 * Developed by: Yamen Saraiji                                          *
 ************************************************************************/

#ifndef __CORERESOURCE__
#define __CORERESOURCE__

#include <utils/atypes.h>

#include <string>

namespace avatarflow {
namespace media {

class VideoFrame;
class AudioFrame;
class DataFrame;

/**
 * @brief Types of resources provided by the core API
 */
enum CoreResourceType {
  Resource_Video,
  Resource_Audio,
  Resource_Data,

  Resource_Other
};

/**
 * @brief Enum of resource providers
 */
enum CoreResourceProvider {
  Provider_Unkown, // unknown (not set)
  Provider_Local,  // provided by local application
  Provider_Remote, // provided from a remote process
};

/**
 * @brief List of flags for a resource
 */
enum CoreResourceFlags {
  ResourceFlag_MediaPeripheral = BIT(0), // generated by a media peripheral
  ResourceFlag_User = BIT(2),            // generated by user
  ResourceFlag_Processed = BIT(3),       // processed data
  ResourceFlag_Read = BIT(4),            // read support
  ResourceFlag_Write = BIT(5),           // write support
  ResourceFlag_ReadWrite = ResourceFlag_Read | ResourceFlag_Write,
};

/**
 * @brief Base class for resource packets and basic meta data, mainly
 * indicating whether its a new frame or old one
 */
class IResourcePacket {
public:
  /** \brief Flag indicating if its a new frame or not */
  bool newFrame;

  /** \brief Name of the resource*/
  std::string name;

  /**
   * @brief information about this resource provider
   */
  CoreResourceProvider provider;

public:
  IResourcePacket() : newFrame(false), provider(Provider_Unkown) {}
  IResourcePacket(bool nf, const std::string &sh) : newFrame(nf), name(sh) {}

  /** \brief Return the type of resource:
   * avatarflow::media::CoreResourceType */
  virtual CoreResourceType GetType() = 0;
};
class VideoResourcePacket : public IResourcePacket {
public:
  const media::VideoFrame *frame;

  VideoResourcePacket() : frame(0) {}
  VideoResourcePacket(const media::VideoFrame *f, bool nf,
                      const std::string &sh)
      : IResourcePacket(nf, sh), frame(f) {}

  virtual CoreResourceType GetType() { return Resource_Video; }
};
class AudioResourcePacket : public IResourcePacket {
public:
  const media::AudioFrame *frame;

  AudioResourcePacket() : frame(0) {}
  AudioResourcePacket(const media::AudioFrame *f, bool nf,
                      const std::string &sh)
      : IResourcePacket(nf, sh), frame(f) {}

  virtual CoreResourceType GetType() { return Resource_Audio; }
};
class DataResourcePacket : public IResourcePacket {
public:
  //
  const media::DataFrame *frame;
  std::string channelName;

  DataResourcePacket() : frame(0), channelName("") {}
  DataResourcePacket(const media::DataFrame *f, const std::string &channel,
                     bool nf, const std::string &sh)
      : IResourcePacket(nf, sh), frame(f), channelName(channel) {}

  virtual CoreResourceType GetType() { return Resource_Data; }
};

} // namespace media
} // namespace avatarflow

#endif //__CORERESOURCE__